<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üìá Contact PDF Reader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#1E429B">
  <link rel="manifest" href="manifest.json">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
  </script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
  <style>
    :root {
      --primary: #1E429B;
      --secondary: #F3802D;
      --bg: #f5f7fa;
      --card-bg: #ffffff;
      --text: #000000;
      --text-light: #000000;
      --highlight: #fff308;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: var(--bg);
      margin: 0;
      padding: 0;
      color: var(--text);
      line-height: 1.5;
      -webkit-tap-highlight-color: transparent;
    }

    .container {
      max-width: 100%;
      margin: 0 auto;
      padding: 16px;
    }

    h1 {
      text-align: center;
      color: var(--primary);
      margin: 16px 0 24px;
      font-size: 1.5rem;
    }

    .input-group {
      position: sticky;
      top: 0;
      background: var(--bg);
      padding: 12px 0;
      z-index: 10;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }

    input[type="file"], input[type="text"] {
      width: 100%;
      padding: 14px 16px;
      border-radius: 12px;
      border: 1px solid #e0e0e0;
      margin: 8px 0;
      font-size: 16px;
      background: var(--card-bg);
      transition: all 0.2s;
    }

    input[type="file"]:focus, input[type="text"]:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(30, 66, 155, 0.2);
    }

    #contacts {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }

    .card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      transition: all 0.2s ease;
      border: 1px solid #eee;
    }

    .card:active {
      transform: scale(0.98);
    }

    .card b {
      color: var(--primary);
      font-size: 17px;
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
    }

    .card p {
      margin: 6px 0;
      color: var(--text-light);
      font-size: 15px;
    }

    .card a {
      color: var(--secondary);
      text-decoration: none;
      font-weight: 500;
    }

    .highlight {
      background-color: var(--highlight);
      padding: 0 2px;
      border-radius: 3px;
    }

    #pagination {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      margin: 24px 0;
      gap: 8px;
    }

    .page-btn {
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      background: var(--primary);
      color: white;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }

    .page-btn:active {
      transform: scale(0.95);
    }

    .page-btn.active {
      background: var(--secondary);
    }

    #status {
      text-align: center;
      margin: 16px 0;
      color: var(--text-light);
      font-size: 14px;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-light);
      grid-column: 1 / -1;
    }

    .card p.raw-text {
      max-height: 100px;
      overflow-y: auto;
      border-top: 1px solid #eee;
      padding-top: 8px;
      margin-top: 8px;
      font-size: 13px;
    }

    @media screen and (max-width: 600px) {
      .container {
        padding: 12px;
      }
      
      h1 {
        font-size: 1.3rem;
        margin: 12px 0 18px;
      }
      
      #contacts {
        grid-template-columns: 1fr;
        gap: 12px;
      }
      
      .card {
        padding: 16px;
      }
      
      .page-btn {
        padding: 8px 12px;
        font-size: 14px;
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .card {
      animation: fadeIn 0.3s ease-out forwards;
      opacity: 0;
    }
  </style>
</head>
<body>

<div class="container">
  <h1>üìá Contact PDF Reader</h1>
  
  <div class="input-group">
    <input type="file" id="fileInput" accept="application/pdf" />
    <input type="text" id="searchInput" placeholder="Search by name, phone, address, email..." />
  </div>
  
  <div id="status">Loading contacts...</div>
  <div id="contacts"></div>
  <div id="pagination"></div>
</div>

<script>
  // Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyBeqaDJLifgdpBQPRL0OLtkovB-m4OM7kw",
    authDomain: "cricker2.firebaseapp.com",
    databaseURL: "https://cricker2-default-rtdb.firebaseio.com",
    projectId: "cricker2",
    storageBucket: "cricker2.appspot.com",
    messagingSenderId: "757574903179",
    appId: "1:757574903179:web:8cfa2a2e3ac157029f7b8e"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // DOM elements
  const fileInput = document.getElementById('fileInput');
  const searchInput = document.getElementById('searchInput');
  const contactsDiv = document.getElementById('contacts');
  const statusDiv = document.getElementById('status');
  const paginationDiv = document.getElementById('pagination');

  // App state
  let allContacts = [];
  let currentPage = 1;
  const contactsPerPage = 40;

  // Highlight search matches
  function highlightText(text, query) {
    if (!query) return text;
    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
    return text.replace(regex, '<span class="highlight">$1</span>');
  }

  // Format name
  function formatName(name) {
    if (!name) return 'Unknown';
    const trimmed = name.trim().replace(/\s+/g, ' ');
    const parts = trimmed.split(/\s+/);
    if (parts.length === 2 && parts[0].endsWith(',')) {
      return `${parts[1]} ${parts[0].replace(',', '')}`;
    }
    return trimmed;
  }

  // Debounce search input
  function debounce(func, delay = 300) {
    let timeout;
    return function (...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), delay);
    };
  }

  // Filter contacts
  function getFilteredContacts() {
    const q = searchInput.value.trim().toLowerCase();
    if (!q || q.length < 2) return allContacts;

    const isNumber = /^\d+$/.test(q.replace(/\s+/g, ''));
    return allContacts.filter(c => {
      const phones = Array.isArray(c.phones) ? c.phones : c.phone ? [c.phone] : [];
      const name = formatName(c.name || '').toLowerCase();
      const address = (c.address || c.village || '').toLowerCase();
      const email = (c.email || '').toLowerCase();
      const village = (c.village || '').toLowerCase();
      const block = (c.block || '').toLowerCase();
      const rawText = (c.rawText || '').toLowerCase();

      if (isNumber) return phones.some(p => p.includes(q)) || rawText.includes(q);
      return (
        name.includes(q) ||
        address.includes(q) ||
        phones.some(p => p.includes(q)) ||
        email.includes(q) ||
        village.includes(q) ||
        block.includes(q) ||
        rawText.includes(q)
      );
    });
  }

  // Render contacts
  function renderContacts() {
    const filtered = getFilteredContacts();
    const total = filtered.length;
    const start = (currentPage - 1) * contactsPerPage;
    const end = start + contactsPerPage;
    const toShow = filtered.slice(start, end);
    const query = searchInput.value.trim().toLowerCase();

    contactsDiv.innerHTML = '';

    if (toShow.length === 0) {
      contactsDiv.innerHTML = '<div class="empty-state">No contacts found. Try a different search.</div>';
    } else {
      toShow.forEach((c, index) => {
        const formattedName = formatName(c.name || 'Unknown');
        const formattedAddress = c.address || (c.village && c.block ? `${c.village}, ${c.block}` : 'No address');
        const phones = Array.isArray(c.phones) ? c.phones : c.phone ? [c.phone] : ['No phone'];
        const formattedPhones = phones.join(', ');
        const formattedEmail = c.email || 'No email';
        const rawText = c.rawText || 'No additional text';

        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <b>${query ? highlightText(formattedName, query) : formattedName}</b>
          <p>üè† ${query ? highlightText(formattedAddress, query) : formattedAddress}</p>
          <p>üìû ${phones.map(p => `<a href="tel:${p}">${query && p.includes(query) ? highlightText(p, query) : p}</a>`).join(', ')}</p>
          <p>üìß ${query ? highlightText(formattedEmail, query) : formattedEmail}</p>
          <p class="raw-text">üìÑ Raw Text: ${query ? highlightText(rawText, query) : rawText}</p>
        `;
        card.style.animationDelay = `${index * 0.05}s`;
        contactsDiv.appendChild(card);
      });
    }

    renderPagination(total);
  }

  // Render pagination
  function renderPagination(totalContacts) {
    const totalPages = Math.ceil(totalContacts / contactsPerPage);
    paginationDiv.innerHTML = '';

    if (totalPages <= 1) return;

    if (currentPage > 1) {
      const prevBtn = document.createElement('button');
      prevBtn.textContent = '‚Üê';
      prevBtn.className = 'page-btn';
      prevBtn.onclick = () => {
        currentPage--;
        renderContacts();
        window.scrollTo({ top: 0, behavior: 'smooth' });
      };
      paginationDiv.appendChild(prevBtn);
    }

    const maxVisible = 5;
    let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
    let endPage = Math.min(totalPages, startPage + maxVisible - 1);

    if (endPage - startPage + 1 < maxVisible) {
      startPage = Math.max(1, endPage - maxVisible + 1);
    }

    for (let i = startPage; i <= endPage; i++) {
      const btn = document.createElement('button');
      btn.textContent = i;
      btn.className = 'page-btn' + (i === currentPage ? ' active' : '');
      btn.onclick = () => {
        currentPage = i;
        renderContacts();
        window.scrollTo({ top: 0, behavior: 'smooth' });
      };
      paginationDiv.appendChild(btn);
    }

    if (currentPage < totalPages) {
      const nextBtn = document.createElement('button');
      nextBtn.textContent = '‚Üí';
      nextBtn.className = 'page-btn';
      nextBtn.onclick = () => {
        currentPage++;
        renderContacts();
        window.scrollTo({ top: 0, behavior: 'smooth' });
      };
      paginationDiv.appendChild(nextBtn);
    }
  }

  // Batch Firebase writes
  async function batchFirebaseWrite(contacts) {
    const batchSize = 20;
    const updates = {};
    contacts.forEach(contact => {
      const id = db.ref('contacts').push().key;
      updates[id] = contact;
    });

    const keys = Object.keys(updates);
    for (let i = 0; i < keys.length; i += batchSize) {
      const batch = {};
      keys.slice(i, i + batchSize).forEach(key => {
        batch[key] = updates[key];
      });
      try {
        await db.ref('contacts').update(batch);
        statusDiv.textContent = `Saved ${Math.min(i + batchSize, keys.length)} of ${keys.length} contacts...`;
      } catch (err) {
        console.error("Firebase batch write error:", err);
        statusDiv.textContent = `‚ö†Ô∏è Error saving contacts: ${err.message}`;
      }
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  // Handle search input
  searchInput.addEventListener('input', debounce(() => {
    currentPage = 1;
    renderContacts();
  }));

  // Handle file upload
  fileInput.addEventListener('change', async e => {
    const file = e.target.files[0];
    if (!file) {
      statusDiv.textContent = "No file selected.";
      return;
    }

    statusDiv.textContent = "Reading PDF...";
    const newContacts = [];
    contactsDiv.innerHTML = '';
    paginationDiv.innerHTML = '';

    try {
      const reader = new FileReader();
      reader.onload = async () => {
        try {
          const startTime = performance.now();
          const typedArray = new Uint8Array(reader.result);
          const pdf = await pdfjsLib.getDocument({ data: typedArray }).promise;

          statusDiv.textContent = `Reading ${pdf.numPages} pages...`;
          let fullText = '';
          for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            fullText += textContent.items.map(item => item.str).join(' ') + '\n';
            statusDiv.textContent = `Processed page ${i} of ${pdf.numPages}...`;
          }

          console.log("Extracted Text Length:", fullText.length);
          console.log("Text Extraction Time:", (performance.now() - startTime) / 1000, "seconds");

          // Try table-based parsing (for "kisan" PDF)
          const tableRegex = /([A-Za-z\s\-]+)\s+([A-Za-z\s\-]+)\s+([A-Za-z\s\-,]+)\s+(\d{10})/g;
          let match;
          while ((match = tableRegex.exec(fullText)) !== null) {
            newContacts.push({
              block: match[1].trim(),
              village: match[2].trim(),
              name: formatName(match[3].trim()),
              phones: [match[4].trim()],
              address: `${match[2].trim()}, ${match[1].trim()}`,
              email: null,
              rawText: match[0]
            });
          }

          if (newContacts.length > 0) {
            console.log("Table-based contacts:", newContacts.length);
          } else {
            statusDiv.textContent = "Parsing semi-structured contacts...";
            // Parse semi-structured format (like afsar.pdf)
            const lines = fullText.split('\n').filter(line => line.trim() && !line.match(/^about\s*blank$|^11\/20\/24|^[0-9\/]+\s*$/));
            const entries = [];
            let currentEntry = [];

            for (const line of lines) {
              if (!line.match(/^(Phone|Address|Email)\s/) && !line.match(/^\d{10,12}|^\+\d+|[\w.-]+@[\w.-]+\.\w+/)) {
                if (currentEntry.length) entries.push(currentEntry.join('\n'));
                currentEntry = [line];
              } else if (currentEntry.length) {
                currentEntry.push(line);
              }
            }
            if (currentEntry.length) entries.push(currentEntry.join('\n'));

            console.log("Entries found:", entries.length);

            const phoneRegex = /(?:\+[\d-]+\s*\d+|\d{10,12}|[\d-]{10,14})(?:\s*\.\s*(?:Mobile|Other|Phone|WhatsApp|Main))?/g;
            const emailRegex = /[\w.-]+@[\w.-]+\.\w+/g;
            const addressRegex = /([A-Za-z\s,]+(?:,\s*[A-Za-z\s]+)*\s*(?:India|Indsa))(?:\s*\.\s*(?:Work|Home))?/g;

            const phones = [...new Set(fullText.match(phoneRegex) || [])].map(p => p.trim());
            const emails = [...new Set(fullText.match(emailRegex) || [])];
            const addresses = [...new Set(fullText.match(addressRegex) || [])].map(a => a.trim());

            console.log("Phones:", phones.length);
            console.log("Emails:", emails.length);
            console.log("Addresses:", addresses.length);

            newContacts.push(...entries.map((entry, index) => {
              const entryPhones = phones.filter(p => entry.includes(p));
              const entryEmail = emails.find(e => entry.includes(e)) || null;
              const entryAddress = addresses.find(a => entry.includes(a)) || null;
              const name = formatName(entry.split('\n')[0].trim()) || `Unknown ${index + 1}`;

              return {
                name,
                phones: entryPhones.length ? entryPhones : ['No phone'],
                address: entryAddress || 'No address',
                email: entryEmail || 'No email',
                rawText: entry
              };
            }));

            console.log("Parsed contacts:", newContacts.length);
          }

          if (newContacts.length === 0) {
            statusDiv.textContent = "‚ö†Ô∏è No contacts found in the PDF.";
            return;
          }

          // Append new contacts to allContacts
          allContacts = [...allContacts, ...newContacts];

          // Save to Firebase
          statusDiv.textContent = "Saving contacts...";
          await batchFirebaseWrite(newContacts);

          statusDiv.textContent = `Loaded ${newContacts.length} new contacts (Total: ${allContacts.length}).`;
          currentPage = 1;
          renderContacts();

          console.log("Total Processing Time:", (performance.now() - startTime) / 1000, "seconds");
        } catch (err) {
          console.error("PDF processing error:", err.message, err.stack);
          statusDiv.textContent = `‚ùå Error processing PDF: ${err.message}`;
        }
      };
      reader.onerror = () => {
        console.error("File reading error");
        statusDiv.textContent = "‚ùå Error reading file.";
      };
      reader.readAsArrayBuffer(file);
    } catch (err) {
      console.error("File input error:", err);
      statusDiv.textContent = "‚ùå File input error.";
    }
  });

  // Load contacts from Firebase
  function loadFromFirebase() {
    statusDiv.textContent = "Loading contacts from database...";
    db.ref('contacts').once('value').then(snapshot => {
      const data = snapshot.val() || {};
      allContacts = Object.values(data).map(contact => ({
        name: formatName(contact.name || 'Unknown'),
        phones: Array.isArray(contact.phones) ? contact.phones : contact.phone ? [contact.phone] : ['No phone'],
        address: contact.address || (contact.village && contact.block ? `${contact.village}, ${contact.block}` : 'No address'),
        email: contact.email || 'No email',
        village: contact.village || '',
        block: contact.block || '',
        rawText: contact.rawText || contact.name || 'No text'
      }));
      console.log("Loaded from Firebase:", allContacts.length);
      currentPage = 1;
      renderContacts();
      statusDiv.textContent = allContacts.length > 0 ?
        `Ready. ${allContacts.length} contacts loaded.` :
        "No contacts found. Upload a PDF to get started.";
    }).catch(err => {
      console.error("Firebase error:", err);
      statusDiv.textContent = "‚ùå Error loading contacts from database.";
    });
  }

  // Initialize the app
  loadFromFirebase();
</script>

</body>
</html>
