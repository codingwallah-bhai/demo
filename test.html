<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Data Extractor | PDF डेटा एक्सट्रैक्टर</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: #f3f4f6;
            margin: 0;
            padding: 1rem;
        }
        .container {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
            max-width: 1200px;
            border: 1px solid #e5e7eb;
        }
        h1 {
            color: #1f2937;
            margin-bottom: 1.5rem;
            font-size: 1.875rem;
            text-align: center;
        }
        label {
            color: #374151;
            font-weight: 500;
            font-size: 0.875rem;
        }
        .input-group {
            margin-bottom: 1rem;
        }
        .search-input, .file-input {
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            width: 100%;
            font-size: 0.875rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .search-input:focus, .file-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }
        .file-input {
            background-color: white;
            cursor: pointer;
        }
        .status-message {
            margin: 1rem 0;
            padding: 0.75rem;
            border-radius: 0.375rem;
            display: none;
            font-size: 0.875rem;
            font-weight: 500;
        }
        .status-loading {
            background-color: #e0f2fe;
            color: #0369a1;
            border: 1px solid #bae6fd;
        }
        .status-error {
            background-color: #fef2f2;
            color: #b91c1c;
            border: 1px solid #fecaca;
        }
        .status-success {
            background-color: #f0fdf4;
            color: #15803d;
            border: 1px solid #bbf7d0;
        }
        .status-info {
            background-color: #f0f9ff;
            color: #1e40af;
            border: 1px solid #bfdbfe;
        }
        .table-container {
            max-height: 70vh;
            overflow-y: auto;
            overflow-x: auto;
            margin-top: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 0.75rem;
            font-size: 0.875rem;
            text-align: left;
            white-space: normal;
            word-wrap: break-word;
        }
        th {
            background-color: #f9fafb;
            font-weight: 600;
            color: #1f2937;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        td {
            color: #374151;
        }
        tr:nth-child(even) {
            background-color: #f9fafb;
        }
        tr:hover {
            background-color: #f3f4f6;
        }
        .pagination-controls {
            margin-top: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }
        .pagination-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            background-color: white;
            color: #374151;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .pagination-btn:hover:not(:disabled) {
            background-color: #f3f4f6;
            border-color: #9ca3af;
        }
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .page-info {
            font-size: 0.875rem;
            color: #6b7280;
        }
        .highlight {
            background-color: #fef08a;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
        }
        .action-btn {
            padding: 0.5rem 1rem;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 0.5rem;
        }
        .action-btn:hover {
            background-color: #4338ca;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PDF डेटा एक्सट्रैक्टर</h1>

        <div class="input-group">
            <label for="pdfFile">PDF फाइल चुनें:</label>
            <input type="file" id="pdfFile" accept=".pdf" class="file-input mt-1">
            <button id="resetBtn" class="action-btn">रीसेट करें</button>
        </div>

        <div class="input-group">
            <label for="searchInput">सभी PDF में डेटा खोजें:</label>
            <input type="text" id="searchInput" class="search-input mt-1" placeholder="खोजें...">
        </div>

        <div id="statusMessage" class="status-message" role="status" aria-live="polite"></div>

        <div class="table-container">
            <table id="dataTable">
                <thead></thead>
                <tbody></tbody>
            </table>
        </div>
        <div id="paginationControls" class="pagination-controls"></div>
    </div>

 <script>
  // Firebase Configuration
const firebaseConfig = {
    apiKey: "AIzaSyBeqaDJLifgdpBQPRL0OLtkovB-m4OM7kw",
    authDomain: "cricker2.firebaseapp.com",
    databaseURL: "https://cricker2-default-rtdb.firebaseio.com",
    projectId: "cricker2",
    storageBucket: "cricker2.appspot.com",
    messagingSenderId: "757574903179",
    appId: "1:757574903179:web:8cfa2a2e3ac157029f7b8e",
    measurementId: "G-DZNF4BTH35"
};

// Initialize Firebase
let firebaseApp;
let db;
try {
    if (typeof firebase !== 'undefined' && firebase.app && !firebase.apps.length) {
        firebaseApp = firebase.initializeApp(firebaseConfig);
        db = firebaseApp.database();
        console.log("Firebase successfully initialized.");
    } else if (typeof firebase !== 'undefined' && firebase.app && firebase.apps.length) {
        firebaseApp = firebase.app();
        db = firebaseApp.database();
        console.log("Firebase already initialized.");
    } else {
        throw new Error("Firebase SDK not loaded. Check your HTML script tags.");
    }
} catch (error) {
    console.error("Error initializing Firebase:", error);
    displayUserMessage("Firebase failed to load. Data will not save/load.", 'error');
}

// DOM Elements
const pdfFileInput = document.getElementById('pdfFile');
const searchInput = document.getElementById('searchInput');
const dataTable = document.getElementById('dataTable');
const tableHead = dataTable.querySelector('thead');
const tableBody = dataTable.querySelector('tbody');
const statusMessage = document.getElementById('statusMessage');
const paginationControls = document.getElementById('paginationControls');
const resetBtn = document.getElementById('resetBtn');

// Global State
let allPdfData = [];
let combinedFlatData = [];
let currentHeaders = [];
let currentFilteredData = [];
let currentPage = 1;
const rowsPerPage = 20;

// Event Listeners
pdfFileInput.addEventListener('change', handleFileSelect);
searchInput.addEventListener('input', debounce(handleSearch, 300));
resetBtn.addEventListener('click', resetTableState);

// PDF.js Worker Setup
if (window.pdfjsLib) {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
} else {
    console.error("PDF.js library not loaded. Check script tag.");
    displayUserMessage("PDF.js failed to load. Check internet connection.", 'error');
}

/**
 * Displays a message to the user.
 * @param {string} message - Message to display.
 * @param {'loading'|'error'|'success'|'info'|''} type - Message type for styling.
 */
function displayUserMessage(message, type) {
    if (!statusMessage) return;
    statusMessage.textContent = message;
    statusMessage.className = 'status-message';
    if (type) statusMessage.classList.add(`status-${type}`);
    statusMessage.style.display = message ? 'block' : 'none';
}

/**
 * Debounces a function call.
 * @param {function} func - Function to debounce.
 * @param {number} wait - Delay in milliseconds.
 * @returns {function} Debounced function.
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func(...args), wait);
    };
}

/**
 * Handles PDF file selection.
 * @param {Event} event - File input change event.
 */
async function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file || file.type !== 'application/pdf') {
        displayUserMessage('Please select a PDF file.', 'error');
        return;
    }

    displayUserMessage('Processing PDF...', 'loading');

    try {
        const fileReader = new FileReader();
        fileReader.onload = async function() {
            const typedarray = new Uint8Array(this.result);
            await parsePdfAndSetupTable(typedarray, file.name);
        };
        fileReader.readAsArrayBuffer(file);
    } catch (error) {
        console.error('Error reading file:', error);
        displayUserMessage('Error reading file.', 'error');
    }
}

/**
 * Parses a PDF, extracts text, infers table structure, and updates global data.
 * @param {Uint8Array} pdfData - PDF file data.
 * @param {string} fileName - PDF file name.
 */
async function parsePdfAndSetupTable(pdfData, fileName) {
    const startTime = performance.now();
    try {
        if (!window.pdfjsLib) {
            displayUserMessage("PDF.js library not loaded.", "error");
            return;
        }
        const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
        const numPages = pdf.numPages;
        let allTextItems = [];

        for (let i = 1; i <= numPages; i++) {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            textContent.items.forEach(item => {
                item.page = i;
                item.originalY = item.transform[5];
                item.originalX = item.transform[4];
                allTextItems.push(item);
            });
        }

        allTextItems.sort((a, b) => {
            if (a.page !== b.page) return a.page - b.page;
            return a.originalY === b.originalY ? a.originalX - b.originalX : b.originalY - a.originalY;
        });

        const mergedTextItems = [];
        let currentItem = null;
        const MERGE_Y_TOLERANCE = 25;
        const MERGE_X_TOLERANCE = 50; // Reduced for better text separation

        for (const item of allTextItems) {
            const itemText = item.str.trim();
            if (!itemText) continue;

            if (!currentItem) {
                currentItem = {
                    text: itemText,
                    x: item.originalX,
                    y: item.originalY,
                    width: item.width,
                    height: item.height,
                    page: item.page
                };
            } else if (
                item.page === currentItem.page &&
                Math.abs(item.originalY - currentItem.y) <= MERGE_Y_TOLERANCE &&
                Math.abs(item.originalX - (currentItem.x + currentItem.width)) <= MERGE_X_TOLERANCE
            ) {
                currentItem.text += ' ' + itemText;
                currentItem.width += item.width;
                currentItem.height = Math.max(currentItem.height, item.height);
            } else {
                mergedTextItems.push(currentItem);
                currentItem = {
                    text: itemText,
                    x: item.originalX,
                    y: item.originalY,
                    width: item.width,
                    height: item.height,
                    page: item.page
                };
            }
        }
        if (currentItem) {
            mergedTextItems.push(currentItem);
        }

        console.log(`Merged ${mergedTextItems.length} text items for ${fileName}.`);

        const lines = [];
        let currentLineItems = [];
        let lastY = -1;
        const LINE_Y_TOLERANCE = 5;

        for (const item of mergedTextItems) {
            if (lastY === -1 || Math.abs(item.y - lastY) < LINE_Y_TOLERANCE) {
                currentLineItems.push(item);
            } else {
                if (currentLineItems.length > 0) lines.push(currentLineItems);
                currentLineItems = [item];
            }
            lastY = item.y;
        }
        if (currentLineItems.length > 0) {
            lines.push(currentLineItems);
        }

        console.log(`Grouped into ${lines.length} lines for ${fileName}.`);

        const rawParsedData = inferTableColumns(lines);

        console.log(`Parsed ${rawParsedData.length} rows for ${fileName}.`);

        if (rawParsedData.length > 0) {
            const { headers, data } = processRawDataForTable(rawParsedData);
            console.log(`Headers: ${headers.length}, Data rows: ${data.length} for ${fileName}.`);

            const pdfEntry = {
                fileName: fileName || `untitled_${Date.now()}.pdf`,
                headers: headers,
                data: data,
                timestamp: new Date().toISOString()
            };

            const existingPdfIndex = allPdfData.findIndex(pdf => pdf.fileName === fileName);

            if (existingPdfIndex === -1) {
                allPdfData.push(pdfEntry);
                if (db) await saveExtractedDataToFirebase(fileName, headers, data, pdfEntry);
            } else {
                allPdfData[existingPdfIndex].data = data;
                allPdfData[existingPdfIndex].headers = headers;
                allPdfData[existingPdfIndex].timestamp = pdfEntry.timestamp;
                displayUserMessage('Updated existing PDF.', 'info');
            }

            updateCombinedAndFilteredData();
            const endTime = performance.now();
            console.log(`${fileName} processed in ${(endTime - startTime).toFixed(2)}ms.`);
            displayUserMessage('PDF processed. Data added to table.', 'success');
        } else {
            displayUserMessage('No data found in PDF.', 'error');
        }
    } catch (error) {
        console.error('Error parsing PDF:', error);
        displayUserMessage(`Error parsing PDF: ${error.message}`, 'error');
    }
}

/**
 * Infers table columns and rows from text item lines.
 * @param {Array<Array<Object>>} linesOfItemObjects - Array of line item arrays.
 * @returns {Array<Array<string>>} - Array of rows organized into columns.
 */
function inferTableColumns(linesOfItemObjects) {
    if (linesOfItemObjects.length === 0) return [];

    const itemStartXFrequencies = new Map();
    let totalLinesWithItems = 0;
    linesOfItemObjects.forEach(lineItems => {
        if (lineItems.length > 0) {
            totalLinesWithItems++;
            const lineUniqueXStarts = new Set();
            lineItems.forEach(item => lineUniqueXStarts.add(Math.round(item.x)));
            lineUniqueXStarts.forEach(x => {
                itemStartXFrequencies.set(x, (itemStartXFrequencies.get(x) || 0) + 1);
            });
        }
    });

    const frequentXStarts = [];
    const minFrequency = Math.max(2, Math.floor(totalLinesWithItems * 0.3));

    itemStartXFrequencies.forEach((count, x) => {
        if (count >= minFrequency) {
            frequentXStarts.push(x);
        }
    });

    if (frequentXStarts.length === 0 && totalLinesWithItems > 0) {
        const allXStarts = new Set();
        linesOfItemObjects.forEach(lineItems => {
            lineItems.forEach(item => allXStarts.add(Math.round(item.x)));
        });
        frequentXStarts.push(...Array.from(allXStarts));
    }

    if (frequentXStarts.length === 0 && linesOfItemObjects.some(line => line.length > 0)) {
        const firstNonEmptyLine = linesOfItemObjects.find(line => line.length > 0);
        if (firstNonEmptyLine) {
            frequentXStarts.push(Math.round(firstNonEmptyLine[0].x));
        }
    }

    frequentXStarts.sort((a, b) => a - b);

    const mergedColumnStarts = [];
    const COLUMN_MERGE_TOLERANCE = 8; // Reduced for better column separation
    const MIN_COLUMN_WIDTH_THRESHOLD = 15; // Reduced for finer columns

    if (frequentXStarts.length > 0) {
        mergedColumnStarts.push(frequentXStarts[0]);
        for (let i = 1; i < frequentXStarts.length; i++) {
            if (frequentXStarts[i] - mergedColumnStarts[mergedColumnStarts.length - 1] >= COLUMN_MERGE_TOLERANCE) {
                mergedColumnStarts.push(frequentXStarts[i]);
            }
        }
    }

    const finalColumnStarts = [];
    const MAX_COLUMNS = 10;

    if (mergedColumnStarts.length > 0) {
        finalColumnStarts.push(mergedColumnStarts[0]);
        for (let i = 1; i < mergedColumnStarts.length && finalColumnStarts.length < MAX_COLUMNS; i++) {
            if (mergedColumnStarts[i] - finalColumnStarts[finalColumnStarts.length - 1] >= MIN_COLUMN_WIDTH_THRESHOLD) {
                finalColumnStarts.push(mergedColumnStarts[i]);
            }
        }
    }

    if (finalColumnStarts.length === 0 && linesOfItemObjects.length > 0) {
        let minX = Infinity;
        linesOfItemObjects.forEach(line => line.forEach(item => {
            if (item.x < minX) minX = item.x;
        }));
        if (minX !== Infinity) {
            finalColumnStarts.push(Math.round(minX));
        } else {
            finalColumnStarts.push(0);
        }
    }

    const structuredData = [];
    linesOfItemObjects.forEach(lineItems => {
        lineItems.sort((a, b) => a.x - b.x);
        const row = Array(finalColumnStarts.length).fill('');

        lineItems.forEach(item => {
            let assignedToColumn = -1;
            let maxOverlap = 0;

            for (let i = 0; i < finalColumnStarts.length; i++) {
                const colStart = finalColumnStarts[i];
                const colEnd = (i + 1 < finalColumnStarts.length) ? finalColumnStarts[i + 1] : colStart + 500;

                const itemStartX = item.x;
                const itemEndX = item.x + item.width;

                const overlapStart = Math.max(itemStartX, colStart);
                const overlapEnd = Math.min(itemEndX, colEnd);
                const currentOverlap = Math.max(0, overlapEnd - overlapStart);

                const significantOverlap = currentOverlap > Math.min(item.width * 0.2, 10);

                if (significantOverlap && currentOverlap > maxOverlap) {
                    maxOverlap = currentOverlap;
                    assignedToColumn = i;
                }
            }

            if (assignedToColumn !== -1) {
                row[assignedToColumn] = row[assignedToColumn]
                    ? (row[assignedToColumn] + ' ' + item.text)
                    : item.text;
            } else if (finalColumnStarts.length > 0 && item.text.trim()) {
                let closestColIndex = 0;
                let minDist = Infinity;
                for (let i = 0; i < finalColumnStarts.length; i++) {
                    const distToColStart = Math.abs(item.x - finalColumnStarts[i]);
                    const distToColEnd = (i + 1 < finalColumnStarts.length) ? Math.abs(item.x - finalColumnStarts[i + 1]) : Infinity;
                    const dist = Math.min(distToColStart, distToColEnd);

                    if (dist < minDist) {
                        minDist = dist;
                        closestColIndex = i;
                    }
                }
                if (minDist < (MIN_COLUMN_WIDTH_THRESHOLD * 2)) {
                    row[closestColIndex] = row[closestColIndex]
                        ? (row[closestColIndex] + ' ' + item.text)
                        : item.text;
                } else {
                    row[finalColumnStarts.length - 1] = row[finalColumnStarts.length - 1]
                        ? (row[finalColumnStarts.length - 1] + ' ' + item.text)
                        : item.text;
                }
            } else if (finalColumnStarts.length === 0 && row.length > 0) {
                row[0] = row[0]
                    ? (row[0] + ' ' + item.text)
                    : item.text;
            }
        });

        const cleanedRow = row.map(cell => cell ? cell.replace(/ {2,}/g, ' ').trim() : '');
        if (cleanedRow.some(cell => cell.trim() !== '')) {
            structuredData.push(cleanedRow);
        }
    });

    console.log('Parsed Structured Data:', structuredData.slice(0, 5));
    console.log('Column Starts:', finalColumnStarts);

    return structuredData;
}

/**
 * Processes raw parsed data into headers and data rows.
 * @param {Array<Array<string>>} structuredStringData - Array of structured rows.
 * @returns {{headers: Array<string>, data: Array<Array<string>>}} - Headers and data rows.
 */
function processRawDataForTable(structuredStringData) {
    if (structuredStringData.length === 0) {
        return { headers: ["No Data"], data: [] };
    }

    let dataStartIndex = 0;
    let finalHeaders = [];

    for (let i = 0; i < structuredStringData.length; i++) {
        const candidateLine = structuredStringData[i];
        if (candidateLine.length > 0) {
            const hasSomeText = candidateLine.some(cell => {
                const trimmedCell = cell.trim();
                return isNaN(parseFloat(trimmedCell)) || trimmedCell === '' || !isFinite(trimmedCell);
            });

            if (hasSomeText || (candidateLine.length === 1 && candidateLine[0].trim() !== '')) {
                finalHeaders = candidateLine;
                dataStartIndex = i + 1;
                break;
            }
        }
    }

    if (finalHeaders.length === 0 && structuredStringData.length > 0) {
        const maxCols = Math.min(structuredStringData.reduce((max, row) => Math.max(max, row.length), 0), 10);
        finalHeaders = Array.from({ length: maxCols > 0 ? maxCols : 1 }, (_, index) => `Column ${index + 1}`);
        dataStartIndex = 0;
    } else if (finalHeaders.length === 0) {
        finalHeaders = ["No Data"];
        dataStartIndex = 0;
    }

    let data = structuredStringData.slice(dataStartIndex);
    data = data.map(row => {
        const newRow = [...row];
        while (newRow.length < finalHeaders.length) {
            newRow.push('');
        }
        return newRow.slice(0, finalHeaders.length);
    });

    console.log('Processed Data:', data.slice(0, 5));

    return { headers: finalHeaders, data };
}

/**
 * Updates combined data and re-renders table.
 */
function updateCombinedAndFilteredData() {
    if (allPdfData.length === 0) {
        currentHeaders = ["No Data"];
        combinedFlatData = [];
        currentFilteredData = [];
    } else {
        const maxColumns = Math.min(Math.max(...allPdfData.map(pdf => pdf.headers.length)), 10);
        currentHeaders = Array.from({ length: maxColumns }, (_, i) => `Column ${i + 1}`);

        combinedFlatData = allPdfData.flatMap(pdf => {
            return pdf.data.map(row => {
                const newRow = [...row];
                while (newRow.length < maxColumns) {
                    newRow.push('');
                }
                return newRow.slice(0, maxColumns);
            });
        });
        console.log('Combined Flat Data:', combinedFlatData.slice(0, 5));
        handleSearch();
    }
    currentPage = 1;
    renderTablePage();
}

/**
 * Highlights search term in text.
 * @param {string} text - Text to highlight.
 * @param {string} term - Search term.
 * @returns {string} - Highlighted HTML string.
 */
function highlightSearchTerm(text, term) {
    if (!term || typeof text !== 'string') return text;
    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedTerm})`, 'gi');
    return text.replace(regex, '<span class="highlight">$1</span>');
}

/**
 * Renders table for the current page.
 */
function renderTablePage() {
    tableHead.innerHTML = '';
    tableBody.innerHTML = '';

    const trHead = document.createElement('tr');
    currentHeaders.forEach(headerText => {
        const th = document.createElement('th');
        th.textContent = headerText;
        trHead.appendChild(th);
    });
    tableHead.appendChild(trHead);

    const startIndex = (currentPage - 1) * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;
    const pageData = currentFilteredData.slice(startIndex, endIndex);

    const searchTerm = searchInput.value.toLowerCase().trim().replace(/\s+/g, ' ');

    if (pageData.length === 0 && currentFilteredData.length === 0 && combinedFlatData.length > 0 && searchTerm !== '') {
        const noResultsRow = document.createElement('tr');
        const noResultsCell = document.createElement('td');
        noResultsCell.colSpan = currentHeaders.length;
        noResultsCell.textContent = 'No results found.';
        noResultsCell.style.textAlign = 'center';
        noResultsCell.style.padding = '1rem';
        noResultsCell.style.color = '#6b7280';
        noResultsRow.appendChild(noResultsCell);
        tableBody.appendChild(noResultsRow);
    } else if (pageData.length === 0 && combinedFlatData.length === 0) {
        const noDataRow = document.createElement('tr');
        const noDataCell = document.createElement('td');
        noDataCell.colSpan = currentHeaders.length;
        noDataCell.textContent = 'No data available. Upload a PDF.';
        noDataCell.style.textAlign = 'center';
        noDataCell.style.padding = '1rem';
        noDataCell.style.color = '#6b7280';
        noDataRow.appendChild(noDataCell);
        tableBody.appendChild(noDataRow);
    } else {
        pageData.forEach(rowData => {
            const tr = document.createElement('tr');
            for (let i = 0; i < currentHeaders.length; i++) {
                const td = document.createElement('td');
                const cellContent = String(rowData[i] || "");
                if (searchTerm) {
                    td.innerHTML = highlightSearchTerm(cellContent, searchTerm);
                } else {
                    td.textContent = cellContent;
                }
                tr.appendChild(td);
            }
            tableBody.appendChild(tr);
        });
    }
    renderPaginationControls();
}

/**
 * Renders pagination controls.
 */
function renderPaginationControls() {
    paginationControls.innerHTML = '';
    const totalRows = currentFilteredData.length;
    const totalPages = Math.ceil(totalRows / rowsPerPage);

    if (totalPages <= 1 && searchInput.value.trim() === '') return;

    const prevButton = document.createElement('button');
    prevButton.textContent = 'Previous';
    prevButton.classList.add('pagination-btn');
    prevButton.disabled = currentPage === 1;
    prevButton.addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            renderTablePage();
        }
    });
    paginationControls.appendChild(prevButton);

    const pageInfo = document.createElement('span');
    pageInfo.classList.add('page-info');
    pageInfo.textContent = `Page ${totalPages === 0 ? 0 : currentPage} / ${totalPages}`;
    paginationControls.appendChild(pageInfo);

    const nextButton = document.createElement('button');
    nextButton.textContent = 'Next';
    nextButton.classList.add('pagination-btn');
    nextButton.disabled = currentPage === totalPages || totalPages === 0;
    nextButton.addEventListener('click', () => {
        if (currentPage < totalPages) {
            currentPage++;
            renderTablePage();
        }
    });
    paginationControls.appendChild(nextButton);
}

/**
 * Resets table and application state.
 */
function resetTableState() {
    allPdfData = [];
    combinedFlatData = [];
    currentHeaders = [];
    currentFilteredData = [];
    currentPage = 1;
    pdfFileInput.value = '';
    searchInput.value = '';
    tableHead.innerHTML = '';
    tableBody.innerHTML = '';
    paginationControls.innerHTML = '';
    displayUserMessage('', '');
    loadAllSavedDataFromFirebase();
}

/**
 * Filters data based on search input.
 */
function handleSearch() {
    const searchTerm = searchInput.value.toLowerCase().trim().replace(/\s+/g, ' ');
    if (!combinedFlatData.length) {
        currentFilteredData = [];
    } else if (!searchTerm) {
        currentFilteredData = [...combinedFlatData];
    } else {
        currentFilteredData = combinedFlatData.filter(row => {
            return Array.isArray(row) && row.some(cell =>
                cell && String(cell).toLowerCase().replace(/\s+/g, ' ').includes(searchTerm)
            );
        });
    }
    console.log('Filtered Data:', currentFilteredData.slice(0, 5));
    currentPage = 1;
    renderTablePage();
}

/**
 * Saves extracted data to Firebase.
 * @param {string} fileName - PDF file name.
 * @param {Array<string>} headers - Column headers.
 * @param {Array<Array<string>>} data - Data rows.
 * @param {Object} pdfEntry - PDF entry object.
 */
async function saveExtractedDataToFirebase(fileName, headers, data, pdfEntry) {
    if (!db) {
        displayUserMessage('Firebase database not connected.', 'error');
        return;
    }
    if (!Array.isArray(data) || data.length === 0 || !Array.isArray(headers) || headers.length === 0) {
        displayUserMessage('No data to save.', 'info');
        return;
    }

    displayUserMessage('Saving data to Firebase...', 'loading');

    try {
        const metadataRef = db.ref('extracted_pdfs_metadata').push();
        const firebaseKey = metadataRef.key;

        await metadataRef.set({
            fileName: fileName || `untitled_${Date.now()}.pdf`,
            timestamp: pdfEntry.timestamp,
            headers: headers,
            totalRows: data.length
        });

        const rowsRef = db.ref(`extracted_pdfs_rows/${firebaseKey}`);
        const rowsObject = {};
        data.forEach((row, index) => {
            rowsObject[index] = row;
        });

        await rowsRef.set(rowsObject);
        pdfEntry.key = firebaseKey;
        displayUserMessage('Data saved to Firebase!', 'success');
    } catch (error) {
        console.error("Error saving to Firebase:", error);
        displayUserMessage(`Firebase error: ${error.message}`, 'error');
    }
}

/**
 * Loads all saved data from Firebase.
 */
async function loadAllSavedDataFromFirebase() {
    if (!db) {
        console.warn('Firebase DB not ready.');
        displayUserMessage("Firebase not ready.", 'error');
        return;
    }

    displayUserMessage('Loading data from Firebase...', 'loading');
    const startTime = performance.now();

    try {
        const metadataRef = db.ref('extracted_pdfs_metadata');
        const metadataSnapshot = await metadataRef.once('value');
        const metadata = metadataSnapshot.val();

        allPdfData = [];
        if (metadata) {
            Object.entries(metadata).forEach(([key, value]) => {
                if (!value.fileName || !value.headers) {
                    console.warn(`Skipping invalid Firebase metadata entry for key ${key}: missing required fields`);
                    return;
                }
                allPdfData.push({
                    key: key,
                    fileName: value.fileName,
                    headers: value.headers,
                    timestamp: value.timestamp || new Date().toISOString(),
                    data: []
                });
            });
            console.log(`Loaded ${allPdfData.length} PDF metadata entries from Firebase in ${(performance.now() - startTime).toFixed(2)}ms.`);
            displayUserMessage(`Loaded ${allPdfData.length} PDF metadata. Now loading data rows...`, 'loading');

            const rowLoadPromises = allPdfData.map(async (pdfEntry) => {
                try {
                    const rowsRef = db.ref(`extracted_pdfs_rows/${pdfEntry.key}`);
                    const rowsSnapshot = await rowsRef.once('value');
                    const rowsData = rowsSnapshot.val();
                    if (rowsData) {
                        pdfEntry.data = Object.values(rowsData);
                    }
                } catch (rowError) {
                    console.error(`Error loading rows for PDF ${pdfEntry.key}:`, rowError);
                    pdfEntry.data = [];
                }
            });

            await Promise.all(rowLoadPromises);

            const endTime = performance.now();
            console.log(`All PDF data loaded in ${(endTime - startTime).toFixed(2)}ms.`);
            displayUserMessage(`All data loaded from Firebase!`, 'success');
        } else {
            allPdfData = [];
            displayUserMessage('No data in Firebase.', 'info');
        }

        updateCombinedAndFilteredData();
    } catch (error) {
        console.error("Error loading from Firebase:", error);
        displayUserMessage(`Error loading data from Firebase: ${error.message}`, 'error');
    }
}

window.addEventListener('load', () => {
    setTimeout(() => {
        if (db) {
            loadAllSavedDataFromFirebase();
        } else {
            displayUserMessage("Firebase not ready yet.", 'info');
        }
    }, 500);
});

</body>
</html>


