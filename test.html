<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Data Extractor | PDF डेटा एक्सट्रैक्टर</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: #f3f4f6;
            margin: 0;
            padding: 1rem;
        }
        .container {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
            max-width: 1200px;
            border: 1px solid #e5e7eb;
        }
        h1 {
            color: #1f2937;
            margin-bottom: 1.5rem;
            font-size: 1.875rem;
            text-align: center;
        }
        label {
            color: #374151;
            font-weight: 500;
            font-size: 0.875rem;
        }
        .input-group {
            margin-bottom: 1rem;
        }
        .search-input, .file-input {
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            width: 100%;
            font-size: 0.875rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .search-input:focus, .file-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }
        .file-input {
            background-color: white;
            cursor: pointer;
        }
        .status-message {
            margin: 1rem 0;
            padding: 0.75rem;
            border-radius: 0.375rem;
            display: none;
            font-size: 0.875rem;
            font-weight: 500;
        }
        .status-loading {
            background-color: #e0f2fe;
            color: #0369a1;
            border: 1px solid #bae6fd;
        }
        .status-error {
            background-color: #fef2f2;
            color: #b91c1c;
            border: 1px solid #fecaca;
        }
        .status-success {
            background-color: #f0fdf4;
            color: #15803d;
            border: 1px solid #bbf7d0;
        }
        .status-info {
            background-color: #f0f9ff;
            color: #1e40af;
            border: 1px solid #bfdbfe;
        }
        .table-container {
            max-height: 70vh;
            overflow-y: auto;
            overflow-x: auto;
            margin-top: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: auto;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 0.75rem;
            font-size: 0.875rem;
            text-align: left;
            white-space: normal;
            word-wrap: break-word;
        }
        th {
            background-color: #f9fafb;
            font-weight: 600;
            color: #1f2937;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        td {
            color: #374151;
        }
        tr:nth-child(even) {
            background-color: #f9fafb;
        }
        tr:hover {
            background-color: #f3f4f6;
        }
        .pagination-controls {
            margin-top: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }
        .pagination-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            background-color: white;
            color: #374151;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .pagination-btn:hover:not(:disabled) {
            background-color: #f3f4f6;
            border-color: #9ca3af;
        }
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .page-info {
            font-size: 0.875rem;
            color: #6b7280;
        }
        .highlight {
            background-color: #fef08a;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
        }
        .action-btn {
            padding: 0.5rem 1rem;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 0.5rem;
        }
        .action-btn:hover {
            background-color: #4338ca;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PDF डेटा एक्सट्रैक्टर</h1>

        <div class="input-group">
            <label for="pdfFile">PDF फाइल चुनें:</label>
            <input type="file" id="pdfFile" accept=".pdf" class="file-input mt-1">
            <button id="resetBtn" class="action-btn">रीसेट करें</button>
        </div>

        <div class="input-group">
            <label for="searchInput">सभी PDF में डेटा खोजें:</label>
            <input type="text" id="searchInput" class="search-input mt-1" placeholder="खोजें...">
        </div>

        <div id="statusMessage" class="status-message" role="status" aria-live="polite"></div>

        <div class="table-container">
            <table id="dataTable">
                <thead></thead>
                <tbody></tbody>
            </table>
        </div>
        <div id="paginationControls" class="pagination-controls"></div>
    </div>

// Firebase Configuration - अपनी असली Firebase डिटेल्स यहाँ डालें
const firebaseConfig = {
    apiKey: "AIzaSyBeqaDJLifgdpBQPRL0OLtkovB-m4OM7kw",
    authDomain: "cricker2.firebaseapp.com",
    databaseURL: "https://cricker2-default-rtdb.firebaseio.com",
    projectId: "cricker2",
    storageBucket: "cricker2.appspot.com",
    messagingSenderId: "757574903179",
    appId: "1:757574903179:web:8cfa2a2e3ac157029f7b8e",
    measurementId: "G-DZNF4BTH35"
};

// Firebase को शुरू करें
let firebaseApp;
let db;
try {
    if (typeof firebase !== 'undefined' && firebase.app && !firebase.apps.length) {
        firebaseApp = firebase.initializeApp(firebaseConfig);
        db = firebaseApp.database();
        console.log("Firebase सफलतापूर्वक शुरू हो गया है।");
    } else if (typeof firebase !== 'undefined' && firebase.app && firebase.apps.length) {
        firebaseApp = firebase.app();
        db = firebaseApp.database();
        console.log("Firebase पहले से ही शुरू है।");
    } else {
        throw new Error("Firebase SDK लोड नहीं हुआ। अपनी HTML स्क्रिप्ट टैग्स जांचें।");
    }
} catch (error) {
    console.error("Firebase शुरू करने में त्रुटि:", error);
    displayUserMessage("Firebase लोड करने में त्रुटि। डेटा सेव/लोड नहीं होगा।", 'error');
}

// DOM एलिमेंट्स
const pdfFileInput = document.getElementById('pdfFile');
const searchInput = document.getElementById('searchInput');
const dataTable = document.getElementById('dataTable');
const tableHead = dataTable.querySelector('thead');
const tableBody = dataTable.querySelector('tbody');
const statusMessage = document.getElementById('statusMessage');
const paginationControls = document.getElementById('paginationControls');
const resetBtn = document.getElementById('resetBtn');

// ग्लोबल स्टेट वेरिएबल्स
let allPdfData = [];
let combinedFlatData = [];
let currentHeaders = [];
let currentFilteredData = [];
let currentPage = 1;
const rowsPerPage = 20;

// इवेंट लिसनर्स
pdfFileInput.addEventListener('change', handleFileSelect);
searchInput.addEventListener('input', debounce(handleSearch, 300));
resetBtn.addEventListener('click', resetTableState);

// PDF.js वर्कर सेटअप
if (window.pdfjsLib) {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
} else {
    console.error("PDF.js लाइब्रेरी लोड नहीं हुई। सुनिश्चित करें कि स्क्रिप्ट टैग सही है।");
    displayUserMessage("PDF.js लोड नहीं हुआ। इंटरनेट कनेक्शन जांचें।", 'error');
}

/**
 * उपयोगकर्ता को संदेश प्रदर्शित करता है।
 * @param {string} message - प्रदर्शित करने वाला संदेश।
 * @param {'loading'|'error'|'success'|'info'|''} type - स्टाइलिंग के लिए संदेश का प्रकार।
 */
function displayUserMessage(message, type) {
    if (!statusMessage) return;
    statusMessage.textContent = message;
    statusMessage.className = 'status-message';
    if (type) statusMessage.classList.add(`status-${type}`);
    statusMessage.style.display = message ? 'block' : 'none';
}

/**
 * फ़ंक्शन कॉल को डीबाउंस करता है।
 * @param {function} func - डीबाउंस करने के लिए फ़ंक्शन।
 * @param {number} wait - मिलीसेकंड में देरी।
 * @returns {function} डीबाउंस किया गया फ़ंक्शन।
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func(...args), wait);
    };
}

/**
 * PDF फ़ाइल के चयन को संभालता है।
 * @param {Event} event - फ़ाइल इनपुट परिवर्तन इवेंट।
 */
async function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file || file.type !== 'application/pdf') {
        displayUserMessage('कृपया एक PDF फाइल चुनें।', 'error');
        return;
    }

    displayUserMessage('PDF प्रोसेस हो रहा है...', 'loading');

    try {
        const fileReader = new FileReader();
        fileReader.onload = async function() {
            const typedarray = new Uint8Array(this.result);
            await parsePdfAndSetupTable(typedarray, file.name);
        };
        fileReader.readAsArrayBuffer(file);
    } catch (error) {
        console.error('फाइल पढ़ने में त्रुटि:', error);
        displayUserMessage('फाइल पढ़ने में त्रुटि।', 'error');
    }
}

/**
 * PDF को पार्स करता है, टेक्स्ट निकालता है, टेबल संरचना का अनुमान लगाता है, और ग्लोबल डेटा को अपडेट करता है।
 * @param {Uint8Array} pdfData - PDF फ़ाइल डेटा।
 * @param {string} fileName - PDF फ़ाइल का नाम।
 */
async function parsePdfAndSetupTable(pdfData, fileName) {
    const startTime = performance.now();
    try {
        if (!window.pdfjsLib) {
            displayUserMessage("PDF.js लाइब्रेरी लोड नहीं हुई है।", "error");
            return;
        }
        const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
        const numPages = pdf.numPages;
        let allTextItems = [];

        for (let i = 1; i <= numPages; i++) {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            textContent.items.forEach(item => {
                item.page = i;
                item.originalY = item.transform[5];
                item.originalX = item.transform[4];
                allTextItems.push(item);
            });
        }

        allTextItems.sort((a, b) => {
            if (a.page !== b.page) return a.page - b.page;
            return a.originalY === b.originalY ? a.originalX - b.originalX : b.originalY - a.originalY;
        });

        const mergedTextItems = [];
        let currentItem = null;
        const MERGE_Y_TOLERANCE = 25;
        const MERGE_X_TOLERANCE = 70;

        for (const item of allTextItems) {
            const itemText = item.str.trim();
            if (!itemText) continue;

            if (!currentItem) {
                currentItem = {
                    text: itemText,
                    x: item.originalX,
                    y: item.originalY,
                    width: item.width,
                    height: item.height,
                    page: item.page
                };
            } else if (
                item.page === currentItem.page SIGNAL तोड़ें
            }
            if (currentItem) {
                mergedTextItems.push(currentItem);
            }
            console.log(`Merged ${mergedTextItems.length} टेक्स्ट आइटम ${fileName} के लिए।`);

            const lines = [];
            let currentLineItems = [];
            let lastY = -1;
            const LINE_Y_TOLERANCE = 5;

            for (const item of mergedTextItems) {
                if (lastY === -1 || Math.abs(item.y - lastY) < LINE_Y_TOLERANCE) {
                    currentLineItems.push(item);
                } else {
                    if (currentLineItems.length > 0) lines.push(currentLineItems);
                    currentLineItems = [item];
                }
                lastY = item.y;
            }
            if (currentLineItems.length > 0) {
                lines.push(currentLineItems);
            }

            console.log(`${fileName} के लिए ${lines.length} लाइनों में समूहीकृत।`);

            const rawParsedData = inferTableColumns(lines);

            console.log(`${fileName} के लिए ${rawParsedData.length} पंक्तियाँ पार्स की गईं।`);

            if (rawParsedData.length > 0) {
                const { headers, data } = processRawDataForTable(rawParsedData);
                console.log(`हेडर: ${headers.length}, डेटा पंक्तियाँ: ${data.length} ${fileName} के लिए।`);

                const pdfEntry = {
                    fileName: fileName || `untitled_${Date.now()}.pdf`,
                    headers: headers,
                    data: data,
                    timestamp: new Date().toISOString()
                };

                const existingPdfIndex = allPdfData.findIndex(pdf => pdf.fileName === fileName);

                if (existingPdfIndex === -1) {
                    allPdfData.push(pdfEntry);
                    if (db) await saveExtractedDataToFirebase(fileName, headers, data, pdfEntry);
                } else {
                    allPdfData[existingPdfIndex].data = data;
                    allPdfData[existingPdfIndex].headers = headers;
                    allPdfData[existingPdfIndex].timestamp = pdfEntry.timestamp;
                    displayUserMessage('मौजूदा PDF को अपडेट किया गया।', 'info');
                }

                updateCombinedAndFilteredData();
                const endTime = performance.now();
                console.log(`${fileName} ${(endTime - startTime).toFixed(2)}ms में प्रोसेस हुआ।`);
                displayUserMessage('PDF प्रोसेस हुआ। डेटा टेबल में जोड़ा गया।', 'success');
            } else {
                displayUserMessage('PDF में कोई डेटा नहीं मिला।', 'error');
            }
        } catch (error) {
            console.error('PDF पार्स करने में त्रुटि:', error);
            displayUserMessage(`PDF पार्स करने में त्रुटि: ${error.message}`, 'error');
        }
    }

    /**
     * टेक्स्ट आइटम की लाइनों से टेबल कॉलम और पंक्तियों का अनुमान लगाता है।
     * @param {Array<Array<Object>>} linesOfItemObjects - वस्तु सरणी की पंक्तियाँ।
     * @returns {Array<Array<string>>} - कॉलम में व्यवस्थित पंक्तियों का एक सरणी।
     */
    function inferTableColumns(linesOfItemObjects) {
        if (linesOfItemObjects.length === 0) return [];

        const itemStartXFrequencies = new Map();
        let totalLinesWithItems = 0;
        linesOfItemObjects.forEach(lineItems => {
            if (lineItems.length > 0) {
                totalLinesWithItems++;
                const lineUniqueXStarts = new Set();
                lineItems.forEach(item => lineUniqueXStarts.add(Math.round(item.x)));
                lineUniqueXStarts.forEach(x => {
                    itemStartXFrequencies.set(x, (itemStartXFrequencies.get(x) || 0) + 1);
                });
            }
        });

        const frequentXStarts = [];
        const minFrequency = Math.max(2, Math.floor(totalLinesWithItems * 0.3));

        itemStartXFrequencies.forEach((count, x) => {
            if (count >= minFrequency) {
                frequentXStarts.push(x);
            }
        });

        if (frequentXStarts.length === 0 && totalLinesWithItems > 0) {
            const allXStarts = new Set();
            linesOfItemObjects.forEach(lineItems => {
                lineItems.forEach(item => allXStarts.add(Math.round(item.x)));
            });
            frequentXStarts.push(...Array.from(allXStarts));
        }

        if (frequentXStarts.length === 0 && linesOfItemObjects.some(line => line.length > 0)) {
            const firstNonEmptyLine = linesOfItemObjects.find(line => line.length > 0);
            if (firstNonEmptyLine) {
                frequentXStarts.push(Math.round(firstNonEmptyLine[0].x));
            }
        }

        frequentXStarts.sort((a, b) => a - b);

        const mergedColumnStarts = [];
        // Modified: Reduced tolerance for better column separation
        const COLUMN_MERGE_TOLERANCE = 10; // Was 15
        const MIN_COLUMN_WIDTH_THRESHOLD = 20; // Was 25

        if (frequentXStarts.length > 0) {
            mergedColumnStarts.push(frequentXStarts[0]);
            for (let i = 1; i < frequentXStarts.length; i++) {
                if (frequentXStarts[i] - mergedColumnStarts[mergedColumnStarts.length - 1] >= COLUMN_MERGE_TOLERANCE) {
                    mergedColumnStarts.push(frequentXStarts[i]);
                }
            }
        }

        const finalColumnStarts = [];
        const MAX_COLUMNS = 10;

        if (mergedColumnStarts.length > 0) {
            finalColumnStarts.push(mergedColumnStarts[0]);
            for (let i = 1; i < mergedColumnStarts.length && finalColumnStarts.length < MAX_COLUMNS; i++) {
                if (mergedColumnStarts[i] - finalColumnStarts[finalColumnStarts.length - 1] >= MIN_COLUMN_WIDTH_THRESHOLD) {
                    finalColumnStarts.push(mergedColumnStarts[i]);
                }
            }
        }

        if (finalColumnStarts.length === 0 && linesOfItemObjects.length > 0) {
            let minX = Infinity;
            linesOfItemObjects.forEach(line => line.forEach(item => {
                if (item.x < minX) minX = item.x;
            }));
            if (minX !== Infinity) {
                finalColumnStarts.push(Math.round(minX));
            } else {
                finalColumnStarts.push(0);
            }
        }

        const structuredData = [];
        linesOfItemObjects.forEach(lineItems => {
            lineItems.sort((a, b) => a.x - b.x);
            const row = Array(finalColumnStarts.length).fill('');

            lineItems.forEach(item => {
                let assignedToColumn = -1;
                let maxOverlap = 0;

                for (let i = 0; i < finalColumnStarts.length; i++) {
                    const colStart = finalColumnStarts[i];
                    const colEnd = (i + 1 < finalColumnStarts.length) ? finalColumnStarts[i + 1] : colStart + 500;

                    const itemStartX = item.x;
                    const itemEndX = item.x + item.width;

                    const overlapStart = Math.max(itemStartX, colStart);
                    const overlapEnd = Math.min(itemEndX, colEnd);
                    const currentOverlap = Math.max(0, overlapEnd - overlapStart);

                    const significantOverlap = currentOverlap > Math.min(item.width * 0.2, 15);

                    if (significantOverlap && currentOverlap > maxOverlap) {
                        maxOverlap = currentOverlap;
                        assignedToColumn = i;
                    }
                }

                if (assignedToColumn !== -1) {
                    row[assignedToColumn] = row[assignedToColumn]
                        ? (row[assignedToColumn] + ' ' + item.text)
                        : item.text;
                } else if (finalColumnStarts.length > 0 && item.text.trim()) {
                    let closestColIndex = 0;
                    let minDist = Infinity;
                    for (let i = 0; i < finalColumnStarts.length; i++) {
                        const distToColStart = Math.abs(item.x - finalColumnStarts[i]);
                        const distToColEnd = (i + 1 < finalColumnStarts.length) ? Math.abs(item.x - finalColumnStarts[i + 1]) : Infinity;
                        const dist = Math.min(distToColStart, distToColEnd);

                        if (dist < minDist) {
                            minDist = dist;
                            closestColIndex = i;
                        }
                    }
                    if (minDist < (MIN_COLUMN_WIDTH_THRESHOLD * 2)) {
                        row[closestColIndex] = row[closestColIndex]
                            ? (row[closestColIndex] + ' ' + item.text)
                            : item.text;
                    } else {
                        row[finalColumnStarts.length - 1] = row[finalColumnStarts.length - 1]
                            ? (row[finalColumnStarts.length - 1] + ' ' + item.text)
                            : item.text;
                    }
                } else if (finalColumnStarts.length === 0 && row.length > 0) {
                    row[0] = row[0]
                        ? (row[0] + ' ' + item.text)
                        : item.text;
                }
            });

            const cleanedRow = row.map(cell => cell ? cell.replace(/ {2,}/g, ' ').trim() : '');
            if (cleanedRow.some(cell => cell.trim() !== '')) {
                structuredData.push(cleanedRow);
            }
        });

        // Modified: Log parsed data for debugging
        console.log('Parsed Structured Data:', structuredData.slice(0, 5)); // Log first 5 rows
        console.log('Column Starts:', finalColumnStarts);

        return structuredData;
    }

    /**
     * कच्चे पार्स किए गए डेटा से हेडर और डेटा पंक्तियों को संसाधित करता है।
     * @param {Array<Array<string>>} structuredStringData - संरचित पंक्तियों का एक सरणी।
     * @returns {{headers: Array<string>, data: Array<Array<string>>}} - हेडर और डेटा पंक्तियाँ।
     */
    function processRawDataForTable(structuredStringData) {
        if (structuredStringData.length === 0) {
            return { headers: ["कोई डेटा नहीं"], data: [] };
        }

        let dataStartIndex = 0;
        let finalHeaders = [];

        for (let i = 0; i < structuredStringData.length; i++) {
            const candidateLine = structuredStringData[i];
            if (candidateLine.length > 0) {
                const hasSomeText = candidateLine.some(cell => {
                    const trimmedCell = cell.trim();
                    return isNaN(parseFloat(trimmedCell)) || trimmedCell === '' || !isFinite(trimmedCell);
                });

                if (hasSomeText || (candidateLine.length === 1 && candidateLine[0].trim() !== '')) {
                    finalHeaders = candidateLine;
                    dataStartIndex = i + 1;
                    break;
                }
            }
        }

        if (finalHeaders.length === 0 && structuredStringData.length > 0) {
            const maxCols = Math.min(structuredStringData.reduce((max, row) => Math.max(max, row.length), 0), 10);
            finalHeaders = Array.from({ length: maxCols > 0 ? maxCols : 1 }, (_, index) => `कॉलम ${index + 1}`);
            dataStartIndex = 0;
        } else if (finalHeaders.length === 0) {
            finalHeaders = ["कोई डेटा नहीं"];
            dataStartIndex = 0;
        }

        let data = structuredStringData.slice(dataStartIndex);
        data = data.map(row => {
            const newRow = [...row];
            while (newRow.length < finalHeaders.length) {
                newRow.push('');
            }
            return newRow.slice(0, finalHeaders.length);
        });

        // Modified: Filter out rows with empty name or number columns (assuming name is column 0, number is column 1)
        data = data.filter(row => row[0]?.trim() && row[1]?.trim());

        return { headers: finalHeaders, data };
    }

    /**
     * सभी PDF डेटा को एक फ्लैट ऐरे में अपडेट करता है और टेबल को री-रेंडर करता है।
     */
    function updateCombinedAndFilteredData() {
        if (allPdfData.length === 0) {
            currentHeaders = ["कोई डेटा नहीं"];
            combinedFlatData = [];
            currentFilteredData = [];
        } else {
            const maxColumns = Math.min(Math.max(...allPdfData.map(pdf => pdf.headers.length)), 10);
            currentHeaders = Array.from({ length: maxColumns }, (_, i) => `कॉलम ${i + 1}`);

            combinedFlatData = allPdfData.flatMap(pdf => {
                return pdf.data.map(row => {
                    const newRow = [...row];
                    while (newRow.length < maxColumns) {
                        newRow.push('');
                    }
                    return newRow.slice(0, maxColumns);
                });
            });
            handleSearch();
        }
        currentPage = 1;
        renderTablePage();
    }

    /**
     * सर्च टर्म को टेक्स्ट में हाइलाइट करता है।
     * @param {string} text - जिस टेक्स्ट में हाइलाइट करना है।
     * @param {string} term - सर्च टर्म।
     * @returns {string} - हाइलाइटेड HTML स्ट्रिंग।
     */
    function highlightSearchTerm(text, term) {
        if (!term || typeof text !== 'string') return text;
        const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`(${escapedTerm})`, 'gi');
        return text.replace(regex, '<span class="highlight">$1</span>');
    }

    /**
     * वर्तमान पेज के लिए टेबल को रेंडर करता है।
     */
    function renderTablePage() {
        tableHead.innerHTML = '';
        tableBody.innerHTML = '';

        const trHead = document.createElement('tr');
        currentHeaders.forEach(headerText => {
            const th = document.createElement('th');
            th.textContent = headerText;
            trHead.appendChild(th);
        });
        tableHead.appendChild(trHead);

        const startIndex = (currentPage - 1) * rowsPerPage;
        const endIndex = startIndex + rowsPerPage;
        const pageData = currentFilteredData.slice(startIndex, endIndex);

        const searchTerm = searchInput.value.toLowerCase().trim().replace(/\s+/g, ' ');

        if (pageData.length === 0 && currentFilteredData.length === 0 && combinedFlatData.length > 0 && searchTerm !== '') {
            const noResultsRow = document.createElement('tr');
            const noResultsCell = document.createElement('td');
            noResultsCell.colSpan = currentHeaders.length;
            noResultsCell.textContent = 'कोई परिणाम नहीं मिला।';
            noResultsCell.style.textAlign = 'center';
            noResultsCell.style.padding = '1rem';
            noResultsCell.style.color = '#6b7280';
            noResultsRow.appendChild(noResultsCell);
            tableBody.appendChild(noResultsRow);
        } else if (pageData.length === 0 && combinedFlatData.length === 0) {
            const noDataRow = document.createElement('tr');
            const noDataCell = document.createElement('td');
            noDataCell.colSpan = currentHeaders.length;
            noDataCell.textContent = 'कोई डेटा नहीं। PDF अपलोड करें।';
            noDataCell.style.textAlign = 'center';
            noDataCell.style.padding = '1rem';
            noDataCell.style.color = '#6b7280';
            noDataRow.appendChild(noDataCell);
            tableBody.appendChild(noDataRow);
        } else {
            pageData.forEach(rowData => {
                const tr = document.createElement('tr');
                for (let i = 0; i < currentHeaders.length; i++) {
                    const td = document.createElement('td');
                    const cellContent = String(rowData[i] || "");
                    if (searchTerm) {
                        td.innerHTML = highlightSearchTerm(cellContent, searchTerm);
                    } else {
                        td.textContent = cellContent;
                    }
                    tr.appendChild(td);
                }
                tableBody.appendChild(tr);
            });
        }
        renderPaginationControls();
    }

    /**
     * पेजिंग नियंत्रणों को रेंडर करता है।
     */
    function renderPaginationControls() {
        paginationControls.innerHTML = '';
        const totalRows = currentFilteredData.length;
        const totalPages = Math.ceil(totalRows / rowsPerPage);

        if (totalPages <= 1 && searchInput.value.trim() === '') return;

        const prevButton = document.createElement('button');
        prevButton.textContent = 'पिछला';
        prevButton.classList.add('pagination-btn');
        prevButton.disabled = currentPage === 1;
        prevButton.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                renderTablePage();
            }
        });
        paginationControls.appendChild(prevButton);

        const pageInfo = document.createElement('span');
        pageInfo.classList.add('page-info');
        pageInfo.textContent = `पेज ${totalPages === 0 ? 0 : currentPage} / ${totalPages}`;
        paginationControls.appendChild(pageInfo);

        const nextButton = document.createElement('button');
        nextButton.textContent = 'अगला';
        nextButton.classList.add('pagination-btn');
        nextButton.disabled = currentPage === totalPages || totalPages === 0;
        nextButton.addEventListener('click', () => {
            if (currentPage < totalPages) {
                currentPage++;
                renderTablePage();
            }
        });
        paginationControls.appendChild(nextButton);
    }

    /**
     * टेबल और एप्लिकेशन की स्थिति को रीसेट करता है।
     */
    function resetTableState() {
        allPdfData = [];
        combinedFlatData = [];
        currentHeaders = [];
        currentFilteredData = [];
        currentPage = 1;
        pdfFileInput.value = '';
        searchInput.value = '';
        tableHead.innerHTML = '';
        tableBody.innerHTML = '';
        paginationControls.innerHTML = '';
        displayUserMessage('', '');
        loadAllSavedDataFromFirebase();
    }

    /**
     * सर्च इनपुट के आधार पर डेटा को फ़िल्टर करता है।
     */
    function handleSearch() {
        const searchTerm = searchInput.value.toLowerCase().trim().replace(/\s+/g, ' ');
        if (!combinedFlatData.length) {
            currentFilteredData = [];
        } else if (!searchTerm) {
            // Modified: Only include rows with non-empty name and number (assuming columns 0 and 1)
            currentFilteredData = combinedFlatData.filter(row => row[0]?.trim() && row[1]?.trim());
        } else {
            currentFilteredData = combinedFlatData.filter(row => {
                const matches = Array.isArray(row) && row.some(cell =>
                    cell && String(cell).toLowerCase().replace(/\s+/g, ' ').includes(searchTerm)
                );
                // Modified: Ensure both name and number columns are non-empty
                return matches && row[0]?.trim() && row[1]?.trim();
            });
        }
        console.log('Filtered Data:', currentFilteredData.slice(0, 5)); // Modified: Log first 5 filtered rows
        currentPage = 1;
        renderTablePage();
    }

    /**
     * Firebase में डेटा सेव करता है।
     * @param {string} fileName - PDF फ़ाइल का नाम।
     * @param {Array<string>} headers - कॉलम हेडर।
     * @param {Array<Array<string>>} data - डेटा पंक्तियाँ।
     * @param {Object} pdfEntry - PDF एंट्री।
     */
    async function saveExtractedDataToFirebase(fileName, headers, data, pdfEntry) {
        if (!db) {
            displayUserMessage('Firebase डेटाबेस नहीं जुड़ा।', 'error');
            return;
        }
        if (!Array.isArray(data) || data.length === 0 || !Array.isArray(headers) || headers.length === 0) {
            displayUserMessage('सेव करने के लिए कोई डेटा नहीं।', 'info');
            return;
        }

        displayUserMessage('Firebase में डेटा सेव हो रहा है...', 'loading');

        try {
            const metadataRef = db.ref('extracted_pdfs_metadata').push();
            const firebaseKey = metadataRef.key;

            await metadataRef.set({
                fileName: fileName || `untitled_${Date.now()}.pdf`,
                timestamp: pdfEntry.timestamp,
                headers: headers,
                totalRows: data.length
            });

            const rowsRef = db.ref(`extracted_pdfs_rows/${firebaseKey}`);
            const rowsObject = {};
            data.forEach((row, index) => {
                rowsObject[index] = row;
            });

            await rowsRef.set(rowsObject);
            pdfEntry.key = firebaseKey;
            displayUserMessage('Firebase में डेटा सेव हुआ!', 'success');
        } catch (error) {
            console.error("Firebase सेव करने में त्रुटि:", error);
            displayUserMessage(`Firebase में त्रुटि: ${error.message}`, 'error');
        }
    }

    /**
     * Firebase से सभी सहेजे गए डेटा को लोड करता है।
     */
    async function loadAllSavedDataFromFirebase() {
        if (!db) {
            console.warn('Firebase DB तैयार नहीं है।');
            displayUserMessage("Firebase तैयार नहीं है।", 'error');
            return;
        }

        displayUserMessage('Firebase से डेटा लोड हो रहा है...', 'loading');
        const startTime = performance.now();

        try {
            const metadataRef = db.ref('extracted_pdfs_metadata');
            const metadataSnapshot = await metadataRef.once('value');
            const metadata = metadataSnapshot.val();

            allPdfData = [];
            if (metadata) {
                Object.entries(metadata).forEach(([key, value]) => {
                    if (!value.fileName || !value.headers) {
                        console.warn(`अमान्य Firebase मेटाडेटा एंट्री छोड़ी जा रही है कुंजी ${key} के साथ: आवश्यक फ़ील्ड गुम हैं`);
                        return;
                    }
                    allPdfData.push({
                        key: key,
                        fileName: value.fileName,
                        headers: value.headers,
                        timestamp: value.timestamp || new Date().toISOString(),
                        data: []
                    });
                });
                console.log(`Firebase से ${allPdfData.length} PDF मेटाडेटा एंट्री ${(performance.now() - startTime).toFixed(2)}ms में लोड हुईं।`);
                displayUserMessage(`Firebase से ${allPdfData.length} PDF का मेटाडेटा लोड हुआ। अब डेटा पंक्तियाँ लोड हो रही हैं...`, 'loading');

                const rowLoadPromises = allPdfData.map(async (pdfEntry) => {
                    try {
                        const rowsRef = db.ref(`extracted_pdfs_rows/${pdfEntry.key}`);
                        const rowsSnapshot = await rowsRef.once('value');
                        const rowsData = rowsSnapshot.val();
                        if (rowsData) {
                            pdfEntry.data = Object.values(rowsData);
                        }
                    } catch (rowError) {
                        console.error(`PDF ${pdfEntry.key} के लिए पंक्तियाँ लोड करने में त्रुटि:`, rowError);
                        pdfEntry.data = [];
                    }
                });

                await Promise.all(rowLoadPromises);

                const endTime = performance.now();
                console.log(`सभी PDF डेटा ${(endTime - startTime).toFixed(2)}ms में लोड हो गया।`);
                displayUserMessage(`Firebase से सारा डेटा लोड हुआ!`, 'success');
            } else {
                allPdfData = [];
                displayUserMessage('Firebase में कोई डेटा नहीं।', 'info');
            }

            updateCombinedAndFilteredData();
        } catch (error) {
            console.error("Firebase लोड करने में त्रुटि:", error);
            displayUserMessage(`Firebase से डेटा लोड करने में त्रुटि: ${error.message}`, 'error');
        }
    }

    window.addEventListener('load', () => {
        setTimeout(() => {
            if (db) {
                loadAllSavedDataFromFirebase();
            } else {
                displayUserMessage("Firebase अभी तक तैयार नहीं है।", 'info');
            }
        }, 500);
    });
</script>

</body>
</html>


